import {
  COMPLETE,
  COMPLETE_ENCODER,
  IDecode,
  IDecoder,
  IDecoderReturn,
  IEncode,
  IEncoder,
  IEncoderReturn,
  INCOMPLETE,
} from './types/types';

/*
Encoder:

- takes a value
- returns a PULL source of Result { done: boolean: value: u8 }

const encoder = encode({ toto })
byte[0] = encoder.next().value;
byte[1] = encoder.next().value;
...

=> converts ONE thing to MANY things


Decoder:

- push SINK of u8
- provides a Result: { done: boolean: value: GValue }

const decoder = decode()
decoder.next(byte[0]);
const value = encoder.next(byte[0]).value;
...

=> converts MANY things to ONE thing

 */

/*----------------*/

export type u8 = number;

/*----------------*/

const encodeStringToU8: IEncode<string, u8> = (
  input: string,
): IEncoder<u8> => {
  let i: number = 0;

  if (!input.endsWith('\0')) {
    input += '\0';
  }

  return (): IEncoderReturn<u8> => {
    if (i < input.length) {
      return input.charCodeAt(i++);
    } else {
      return COMPLETE;
    }
  };
};

const u8ToString: IDecode<u8, string> = (): IDecoder<u8, string> => {
  let output: string = '';

  return (
    value: u8,
  ): IDecoderReturn<string> => {
    if (value === 0) {
      return output;
    } else {
      output += String.fromCharCode(value);
      return INCOMPLETE;
    }
  };
};

function encodeToUint8Array(
  encoder: IEncoder<u8>,
  data: Uint8Array = new Uint8Array(1e6),
): Uint8Array {
  let i: number = 0;
  let value: IEncoderReturn<u8>;
  while ((value = encoder()) !== COMPLETE) {
    data[i++] = value;
  }
  return data.subarray(0, i);
}

function decodeFromUint8Array<GValue>(
  decoder: IDecoder<u8, GValue>,
  data: Uint8Array,
): [GValue, Uint8Array] {
  let i: number = 0;
  let value: IDecoderReturn<GValue>;
  while ((value = decoder(data[i++])) === INCOMPLETE) {
  }
  return [
    value,
    data.subarray(i),
  ];
}

function codec<GValue, GEncoded>(
  value: GValue,
  encode: IEncode<GValue, GEncoded>,
  decode: IDecode<GEncoded, GValue>,
): void {
  const encoder: IEncoder<GEncoded> = encode(value);
  const decoder: IDecoder<GEncoded, GValue> = decode();

  let encodedValue: IEncoderReturn<GEncoded>;
  let decodedValue: IDecoderReturn<GValue>;

  do {
    encodedValue = encoder();
    if (encodedValue === COMPLETE) {
      throw new Error(`Encoder finished before Decoder finished`);
    } else {
      decodedValue = decoder(encodedValue);
    }
  } while (decodedValue === INCOMPLETE);

  if (encoder() !== COMPLETE) {
    throw new Error(`Decoder finished before Encoder finished`);
  } else if (decodedValue !== value) {
    throw new Error(`Decoded value is different than encoded value`);
  }
}

/*----------------*/

function debugSuperCodec1(): void {
  const encoder = encodeStringToU8('abc');
  const data = encodeToUint8Array(encoder);
  console.log(data);

  const decoder = u8ToString();
  const [value, _data] = decodeFromUint8Array(decoder, data);
  console.log(value, _data);
}

/*----------------*/

export function jbson_encode_size(
  size: number,
): IEncoder<u8> {
  return e_do_while(
    { size },
    (ctx): IEncoder<u8> => {
      let byte: number = (size & 0b01111111);
      size >>= 7;
      byte |= ((size !== 0) as any) << 7;
      return e_value(byte);
    },
    ({ size }) => size !== 0,
  );
}


// export function jbson_encode_size(
//   size: number,
// ): IEncoder<u8> {
//   let next: IEncoder<u8>;
//   let byte: number;
//
//   const next0 = (): IEncoderReturn<u8> => {
//     byte = (size & 0b01111111);
//     size >>= 7;
//     byte |= ((size !== 0) as any) << 7;
//     next = next1;
//     return byte;
//   };
//
//   const next1 = (): IEncoderReturn<u8> => {
//     if (size === 0) {
//       next = COMPLETE_ENCODER;
//     } else {
//       next = next0;
//     }
//     return next();
//   };
//
//   next = next0;
//
//   return (): IEncoderReturn<u8> => next();
// }

export function jbson_decode_size(): IDecoder<u8, number> {
  let next: IDecoder<u8, number>;
  let size: number;
  let offset: number;

  const next0 = (
    byte: u8,
  ): IDecoderReturn<number> => {
    size = 0;
    offset = 0;
    next = next1;
    return next(byte);
  };

  const next1 = (
    byte: u8,
  ): IDecoderReturn<number> => {
    size |= (byte & 0b01111111) << offset;
    if (byte & 0b10000000) {
      offset += 7;
      return INCOMPLETE;
    } else {
      next = next2;
      return next(byte);
    }
  };

  const next2 = (): IDecoderReturn<number> => {
    return size;
  };

  next = next0;

  return (value: u8): IDecoderReturn<number> => next(value);
}

/*---*/

function encode<GOut>(
  encoder: IEncoder<GOut>,
  observer: (value: GOut) => void,
): void {
  let value: IEncoderReturn<GOut>;
  while ((value = encoder()) !== COMPLETE) {
    observer(value);
  }
}

function encode_to_array<GOut>(
  encoder: IEncoder<GOut>,
): GOut[] {
  const array: GOut[] = [];
  encode(encoder, (value: GOut): void => {
    array.push(value);
  });
  return array;
}

/*---*/

interface IStatementWithContext<GContext extends object, GOut> {
  (context: GContext): IEncoder<GOut>;
}

interface IStatement<GOut> {
  (): IEncoder<GOut>;
}

function context_proxy<GContext extends object>(
  contexts: readonly object[],
): GContext {
  const map = new Map<PropertyKey, object>(
    contexts.flatMap((context: object) => {
      return Object.keys(context).map((key: string): [string, object] => {
        return [
          key,
          context,
        ];
      });
    }),
  );

  return new Proxy<GContext>({} as any, {
    get(
      target: GContext,
      propertyKey: PropertyKey,
      receiver: any,
    ): any {
      if (map.has(propertyKey)) {
        return Reflect.get(map.get(propertyKey)!, propertyKey);
        // return map.get(propertyKey)![propertyKey];
      } else {
        return void 0;
      }
    },
    set(
      target: GContext,
      propertyKey: PropertyKey,
      value: any,
      receiver: any,
    ): any {
      if (map.has(propertyKey)) {
        return Reflect.set(map.get(propertyKey)!, propertyKey, value);
        // return map.get(propertyKey)![propertyKey];
      } else {
        return false;
      }
    },
    has(
      target: GContext,
      propertyKey: PropertyKey,
    ): boolean {
      if (map.has(propertyKey)) {
        return Reflect.has(map.get(propertyKey)!, propertyKey);
      } else {
        return false;
      }
    },
    ownKeys(
      target: GContext,
    ): ArrayLike<string | symbol> {
      return contexts.flatMap((context: object): (string | symbol)[] => {
        return Reflect.ownKeys(context);
      });
    },
  });
}

function chain_encoders<GOut>(
  encoderA: IEncoder<GOut>,
  encoderB: IEncoder<GOut>,
): IEncoder<GOut> {
  let next: IEncoder<GOut> = (): IEncoderReturn<GOut> => {
    const result: IEncoderReturn<GOut> = encoderA();
    if (result === COMPLETE) {
      next = encoderB;
      return next();
    } else {
      return result;
    }
  };
  return (): IEncoderReturn<GOut> => next();
}

function chain_statements<GContext extends object, GOut>(
  statementA: IStatementWithContext<GContext, GOut>,
  statementB: IStatementWithContext<GContext, GOut>,
): IStatementWithContext<GContext, GOut> {
  return (context: GContext) => chain_encoders<GOut>(
    statementA(context),
    statementB(context),
  );
}

function e_array<GOut>(
  values: readonly GOut[],
): IEncoder<GOut> {
  let i: number = 0;

  let next: IEncoder<GOut> = (): IEncoderReturn<GOut> => {
    if (i < values.length) {
      return values[i++];
    } else {
      next = COMPLETE_ENCODER;
      return next();
    }
  };

  return (): IEncoderReturn<GOut> => next();
}

function e_value<GOut>(
  value: GOut,
): IEncoder<GOut> {
  let next: IEncoder<GOut> = (): IEncoderReturn<GOut> => {
    next = COMPLETE_ENCODER;
    return value;
  };

  return (): IEncoderReturn<GOut> => next();
}



function e_while<GOut>(
  condition: () => boolean,
  statement: IStatementWithContext<GContext, GOut>,
): IEncoder<GOut> {
  let next: IEncoder<GOut>;

  const next0 = (): IEncoderReturn<GOut> => {
    if (condition(context)) {
      next = chain_encoders(
        statement(context),
        next0,
      );
    } else {
      next = COMPLETE_ENCODER;
    }
    return next();
  };

  next = next0;

  return (): IEncoderReturn<GOut> => next();
}

function e_while_ctx<GContext extends object, GOut>(
  context: GContext,
  condition: (context: GContext) => boolean,
  statement: IStatementWithContext<GContext, GOut>,
): IEncoder<GOut> {
  let next: IEncoder<GOut>;

  const next0 = (): IEncoderReturn<GOut> => {
    if (condition(context)) {
      next = chain_encoders(
        statement(context),
        next0,
      );
    } else {
      next = COMPLETE_ENCODER;
    }
    return next();
  };

  next = next0;

  return (): IEncoderReturn<GOut> => next();
}


function e_do_while<GContext extends object, GOut>(
  context: GContext,
  statement: IStatementWithContext<GContext, GOut>,
  condition: (context: GContext) => boolean,
): IEncoder<GOut> {
  let next: IEncoder<GOut>;

  const next0 = (): IEncoderReturn<GOut> => {
    next = chain_encoders(
      statement(context),
      next1,
    );
    return next();
  };

  const next1 = (): IEncoderReturn<GOut> => {
    if (condition(context)) {
      next = next0;
    } else {
      next = COMPLETE_ENCODER;
    }
    return next();
  };

  next = next0;

  return (): IEncoderReturn<GOut> => next();
}

function e_for<GContext extends object, GLocalContext extends object, GOut>(
  context: GContext,
  initialization: (context: GContext) => GLocalContext,
  condition: (context: GContext & GLocalContext) => boolean,
  finalExpression: (context: GContext & GLocalContext) => void,
  statement: IStatementWithContext<GContext & GLocalContext, GOut>,
): IEncoder<GOut> {
  let next: IEncoder<GOut>;
  type GFullContext = GContext & GLocalContext;
  let fullContext: GFullContext;

  const next0 = (): IEncoderReturn<GOut> => {
    fullContext = context_proxy<GFullContext>([
      context,
      initialization(context),
    ]);
    next = next1;
    return next();
  };

  const next1 = (): IEncoderReturn<GOut> => {
    next = e_while_ctx<GFullContext, GOut>(
      fullContext,
      condition,
      chain_statements<GFullContext, GOut>(
        statement,
        (context: GFullContext): IEncoder<GOut> => {
          finalExpression(context);
          return next1;
        },
      ),
    );
    return next();
  };

  next = next0;

  return (): IEncoderReturn<GOut> => next();
}

/*---*/

function debugEncoders(): void {
  // const encoder = jbson_encode_size(130);
  // const data = encodeToUint8Array(encoder);
  // console.log(data);
  // e_while();

  const debugContextProxy = () => {
    const ctx1 = { a: 'a', c: 'c-a' };
    const ctx2 = { b: 'b', c: 'c-b' };

    const ctx = context_proxy([ctx1, ctx2]);
    console.log(ctx['a']);
    console.log(ctx['c']);
    ctx['a'] = 'a1';
    ctx['c'] = 'c1';
    console.log(ctx1, ctx2);
  };

  const debug_e_while = () => {
    const ctx = { i: 0 };
    const it = e_while_ctx(
      ctx,
      ({ i }) => (i < 10),
      chain_statements(
        ({ i }) => e_value(i),
        (ctx) => {
          ctx['i']++;
          return COMPLETE_ENCODER;
        },
      )
    );

    console.log(encode_to_array(it));
  };

  const debug_e_for = () => {
    // const ctx = { i: 0 };
    const it = e_for(
      {},
      () => ({ i: 0 }),
      ({ i }) => (i < 10),
      (ctx) => {
        ctx['i']++;
      },
      ({ i }) => e_value(i),
    );

    console.log(encode_to_array(it));
  };

  // debugContextProxy();
  // debug_e_while();
  debug_e_for();

}

/*---*/

export function jbson_encode_uint8_array(
  array: Uint8Array,
): IEncoder<u8> {
  let next: IEncoder<u8>;
  let sizeEncoder: IEncoder<u8>;

  const next0 = (): IEncoderReturn<u8> => {
    sizeEncoder = jbson_encode_size(array.length);
    next = next1;
    return next();
  };

  const next1 = (): IEncoderReturn<u8> => {
    const result: IEncoderReturn<u8> = sizeEncoder();
    if (result === COMPLETE) {
      next = next2;
      return next();
    } else {
      return result;
    }
  };

  let i: number;
  let l: number;

  const next2 = (): IEncoderReturn<u8> => {
    i = 0;
    l = array.length;
    next = next3;
    return next();
  };

  const next3 = (): IEncoderReturn<u8> => {
    if (i < l) {
      return array[i++];
    } else {
      next = COMPLETE_ENCODER;
      return next();
    }
  };

  next = next0;

  return (): IEncoderReturn<u8> => next();
}

/*----------------*/

function debugJBSON(): void {
  // const encoder = jbson_encode_size(130);
  // const data = encodeToUint8Array(encoder);
  // console.log(data);
  console.log(encode_to_array(jbson_encode_size(130)));
  // codec(130, jbson_encode_size, jbson_decode_size);

}

/*----------------*/

export function debugSuperCodec(): void {
  // debugSuperCodec1();
  // debugEncoders();
  debugJBSON();
}

