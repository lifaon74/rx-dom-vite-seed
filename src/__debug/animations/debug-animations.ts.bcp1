/* TRANSITION */

export type ITransitionProgress = number; // [0, 1]

export interface ITransitionFunction<GValue> {
  (
    progress: ITransitionProgress,
  ): GValue;
}

export function scaleTransition<GValue>(
  transition: ITransitionFunction<GValue>,
  scale: number,
): ITransitionFunction<GValue> {
  return (
    progress: ITransitionProgress,
  ): GValue => {
    return transition(progress * scale);
  };
}

export function mapTransition<GIn, GOut>(
  transition: ITransitionFunction<GIn>,
  map: (value: GIn) => GOut,
): ITransitionFunction<GOut> {
  return (
    progress: ITransitionProgress,
  ): GOut => {
    return map(transition(progress));
  };
}

/*---*/

export const TRANSITION_START_EVENT = -Number.POSITIVE_INFINITY;

export type ITransitionStartEvent = typeof TRANSITION_START_EVENT;

export function isTransitionStartEvent(
  input: unknown,
): input is ITransitionStartEvent {
  return (input === TRANSITION_START_EVENT);
}

export const TRANSITION_END_EVENT = Number.POSITIVE_INFINITY;

export type ITransitionEndEvent = typeof TRANSITION_END_EVENT;

export function isTransitionEndEvent(
  input: unknown,
): input is ITransitionStartEvent {
  return (input === TRANSITION_END_EVENT);
}

export type ITransitionProgressWithEvent =
  | ITransitionProgress
  | ITransitionStartEvent
  | ITransitionEndEvent
  ;

export interface ITransitionFunctionWithEvent<GValue> {
  (
    progress: ITransitionProgressWithEvent,
  ): GValue;
}

// export function transitionWithEventToTransition<GValue>(
//   transition: ITransitionFunction<GValue>,
//   onStart: () => GValue,
// ): ITransitionFunctionWithEvent<GValue> {
//   return (
//     progress: ITransitionProgressWithEvent,
//   ): GValue => {
//     if (isTransitionStart(progress)) {
//       return onStart();
//     } else {
//       return transition(progress);
//     }
//   };
// }

export interface ITransitionFactory<GValue> {
  (): ITransitionFunction<GValue>;
}

export interface ITransitionEndFunction<GValue> {
  (
    transition: ITransitionFunction<GValue>,
  ): GValue;
}

export function upgradeTransitionWithEvent<GValue>(
  transitionFactory: ITransitionFactory<GValue>,
  transitionEnd?: ITransitionEndFunction<GValue>,
): ITransitionFunctionWithEvent<GValue> {
  let transition: ITransitionFunction<GValue>;
  return (
    progress: ITransitionProgressWithEvent,
  ): GValue => {
    if (isTransitionStartEvent(progress)) {
      transition = transitionFactory();
      return transition(0);
    } else if (isTransitionEndEvent(progress)) {
      return (transitionEnd === void 0)
        ? transition(1)
        : transitionEnd(transition);
    } else {
      return transition(progress);
    }
  };
}

/* COLOR */

export type IColorNumber = number;

function clampColorChanel(
  value: number,
): number {
  return Math.max(0, Math.min(0xff, Math.round(value)));
}

export function createColorTransition(
  colorA: IColorNumber,
  colorB: IColorNumber,
): ITransitionFunction<IColorNumber> {
  return (
    progress: ITransitionProgress,
  ): IColorNumber => {
    const pA: number = 1 - progress;
    const rA: number = (colorA >>> 24) & 0xff;
    const gA: number = (colorA >>> 16) & 0xff;
    const bA: number = (colorA >>> 8) & 0xff;
    const aA: number = (colorA >>> 0) & 0xff;

    const pB: number = progress;
    const rB: number = (colorB >>> 24) & 0xff;
    const gB: number = (colorB >>> 16) & 0xff;
    const bB: number = (colorB >>> 8) & 0xff;
    const aB: number = (colorB >>> 0) & 0xff;

    const rC: number = clampColorChanel((rA * pA) + (rB * pB));
    const gC: number = clampColorChanel((gA * pA) + (gB * pB));
    const bC: number = clampColorChanel((bA * pA) + (bB * pB));
    const aC: number = clampColorChanel((aA * pA) + (aB * pB));

    return (
      (rC << 24)
      | (gC << 16)
      | (bC << 8)
      | aC
    ) >>> 0;
  };
}

/* NUMBER */

export function createNumberTransition(
  numberA: number,
  numberB: number,
): ITransitionFunction<number> {
  return (
    progress: ITransitionProgress,
  ): number => {
    return (numberA * (1 - progress)) + (numberB * progress);
  };
}

export function createPxTransition(
  pxA: number,
  pxB: number,
): ITransitionFunction<string> {
  return mapTransition(
    createNumberTransition(pxA, pxB),
    _ => `${_}px`,
  );
}

/*---*/

export function createStylePropertyTransition(
  element: HTMLElement,
  propertyName: string,
  transition: ITransitionFunction<string>,
): ITransitionFunction<void> {
  return (
    progress: ITransitionProgress,
  ): void => {
    element.style.setProperty(propertyName, transition(progress));
  };
}

export interface ICreateStylePropertyTransitionWithEventTransitionFactory {
  (
    element: HTMLElement,
    propertyName: string,
  ): ITransitionFunction<string>;
}

export interface ICreateStylePropertyTransitionWithEventTransitionEndFunction {
  (
    element: HTMLElement,
    propertyName: string,
    transition: ITransitionFunction<void>,
  ): string;
}

export function createStylePropertyTransitionWithEvent(
  element: HTMLElement,
  propertyName: string,
  transitionFactory: ICreateStylePropertyTransitionWithEventTransitionFactory,
  transitionEnd?: ICreateStylePropertyTransitionWithEventTransitionEndFunction,
): ITransitionFunctionWithEvent<void> {
  return upgradeTransitionWithEvent<void>(
    (): ITransitionFunction<void> => {
      return createStylePropertyTransition(
        element,
        propertyName,
        transitionFactory(element, propertyName),
      );
    },
    (transitionEnd === void 0)
      ? void 0
      : (
        transition: ITransitionFunction<void>,
      ): void => {
        element.style.setProperty(propertyName, transitionEnd(
          element,
          propertyName,
          transition,
        ));
      },
  );
}

/*--------*/

export type ITransitionWithWeight = [
  transtion: ITransitionFunction<void>,
  weight: number,
];


// function computeChainedTransitionSteps(
//   transitions: readonly ITransitionWithWeight[],
// ): number[] {
//   const length: number = transitions.length;
//   const steps: number[] = new Array<number>(length);
//
//   let total: number = 0;
//
//   for (let i = 0; i < length; i++) {
//     total += transitions[i][1];
//     steps[i] = total;
//   }
//
//   for (let i = 0; i < length; i++) {
//     steps[i] /= total;
//   }
//
//   return steps;
// }


function computeChainedTransitionSteps(
  transitions: readonly ITransitionWithWeight[],
): number[] {
  const length: number = transitions.length;
  const lengthMinusOne: number = length - 1;
  const steps: number[] = new Array<number>(lengthMinusOne);

  let total: number = 0;

  for (let i = 0; i < length; i++) {
    total += transitions[i][1];
  }

  let step: number = 0;

  for (let i = 0; i < lengthMinusOne; i++) {
    step += transitions[i][1] / total;
    steps[i] = step;
  }

  return steps;
}

export function chainTransitions(
  transitions: readonly ITransitionWithWeight[],
): ITransitionFunction<void> {
  // const steps: number[] = computeChainedTransitionSteps(transitions);
  const length: number = transitions.length;
  const lengthMinusOne: number = length - 1;

  // console.log(steps);
  return (
    progress: ITransitionProgressWithEvent,
  ): void => {
    let index: number = 0;

    for (let i = 0; i < length; i++) {
      const [transition, weight] = transitions[i];
      transition(0);
    }

    // const index: number = weights.lastIndexOf((weight: number): boolean => {
    //   return ;
    // });
    // const p: number = progress * total;
  };
}

/*--------*/

function animate(
  duration: number,
  callback: ITransitionFunctionWithEvent<void>,
): void {
  const startTime: number = Date.now();

  const loop = () => {
    const progress: ITransitionProgress = Math.min(1, (Date.now() - startTime) / duration);
    callback(progress);

    if (progress < 1) {
      requestAnimationFrame(loop);
    } else {
      callback(TRANSITION_END_EVENT);
    }
  };
  callback(TRANSITION_START_EVENT);
  callback(0);

  requestAnimationFrame(loop);
}

/*--------*/

export function colorStringToColorNumber(
  input: string,
): IColorNumber {
  const element = document.createElement('div');
  document.body.appendChild(element);
  element.style.color = input;
  const color: string = getComputedStyle(element).getPropertyValue('color');
  document.body.removeChild(element);
  const match = new RegExp('rgb(a?)\\(\\s*(\\d+)\\s*,\\s*(\\d+),\\s*(\\d+)(?:(?:,\\s*(\\d+\\.*\\d+)\\s*)?)\\)').exec(color);
  if (match === null) {
    throw new Error(`Unable to parse color: ${input}`);
  } else {
    const r: number = clampColorChanel(Number(match[2]));
    const g: number = clampColorChanel(Number(match[3]));
    const b: number = clampColorChanel(Number(match[4]));
    const a: number = clampColorChanel(Number(match[5] ?? 1) * 255);

    return (
      (r << 24)
      | (g << 16)
      | (b << 8)
      | a
    ) >>> 0;
  }
}

export function colorNumberToColorString(
  input: IColorNumber,
): string {
  return `#${input.toString(16).padStart(8, '0')}`;
}

/*----------------*/

function createDummyElement(): HTMLElement {
  const element = document.createElement('div');
  // element.style.height = '200px';
  element.style.width = '200px';
  element.style.background = 'red';
  element.innerText = `
  Vivamus dictum lectus sit amet viverra vestibulum. Quisque hendrerit, lorem et viverra aliquam, felis elit hendrerit sem, sed finibus velit erat a eros. Suspendisse ultrices dignissim malesuada. Aliquam ac rutrum felis, id lacinia eros. Sed tincidunt fermentum metus, sit amet suscipit felis varius eu. Morbi ac risus dolor. Nulla facilisi. Sed quis dignissim lectus, in lobortis urna. Suspendisse auctor, arcu non rhoncus tristique, nisi dolor tincidunt magna, imperdiet pellentesque eros mauris tristique risus. Proin sed lorem maximus, viverra nisi at, sodales elit. Nunc eleifend enim a metus volutpat, at ultricies nibh fermentum. Proin dictum ante sed pharetra ultricies. Nam urna orci, maximus vitae gravida quis, lacinia ac nisi. Morbi vestibulum libero sit amet ipsum tristique, sed viverra dolor condimentum. Curabitur ut volutpat nibh, in rutrum augue.
  `;
  element.style.overflow = 'hidden';

  document.body.appendChild(element);
  return element;
}

/*----------------*/

function debugAnimations1() {
  const element = createDummyElement();
  const colorA = colorStringToColorNumber('rgb(255, 0, 0)');
  const colorB = colorStringToColorNumber('rgba(0, 255, 0)');

  // const colorTransition = createColorTransition(colorA, colorB);
  // const colorTransition = upgradeTransitionWithEvent(() => createColorTransition(colorStringToColorNumber(getComputedStyle(element).getPropertyValue('background-color')), colorB));

  // const pxTransition = createPxTransition(100, 300);
  // const translateXTransition = mapTransition(
  //   pxTransition,
  //   _ => `translateX(${_})`,
  // );

  const backgroundColorTransition = createStylePropertyTransitionWithEvent(
    element,
    'background-color',
    () => {
      return mapTransition(
        createColorTransition(colorA, colorB),
        colorNumberToColorString,
      );
    },
  );

  const translateTransition = createStylePropertyTransitionWithEvent(
    element,
    'transform',
    (
      element: HTMLElement,
      propertyName: string,
    ) => {
      return mapTransition(
        createPxTransition(100, 300),
        _ => `translateX(${_})`,
      );
    },
  );

  const collapseTransition = createStylePropertyTransitionWithEvent(
    element,
    'max-height',
    (
      element: HTMLElement,
      propertyName: string,
    ) => {
      const maxHeight: string = element.style.getPropertyValue('max-height');
      element.style.setProperty('max-height', 'none');
      const start: number = element.offsetHeight;
      const end: number = 0;

      if (maxHeight === '') {
        element.style.removeProperty('max-height');
      } else {
        element.style.setProperty('max-height', maxHeight);
      }
      return createPxTransition(start, end);
    },
  );

  const expandTransition = createStylePropertyTransitionWithEvent(
    element,
    'max-height',
    (
      element: HTMLElement,
      propertyName: string,
    ) => {
      const maxHeight: string = element.style.getPropertyValue('max-height');
      element.style.setProperty('max-height', 'none');
      const start: number = 0;
      const end: number = element.offsetHeight;

      if (maxHeight === '') {
        element.style.removeProperty('max-height');
      } else {
        element.style.setProperty('max-height', maxHeight);
      }
      return createPxTransition(start, end);
    },
    (): string => {
      return 'none';
    },
  );

  const chain = chainTransitions([
    [backgroundColorTransition, 1],
    [translateTransition, 1],
  ]);

  animate(2000, (progress: number) => {
    // backgroundColorTransition(progress);
    // translateTransition(progress);
    chain(progress);
    // collapseTransition(progress);
    // expandTransition(progress);
    // element.style.background = colorNumberToColorString(colorTransition(progress));
    // element.style.transform = translateXTransition(progress);
  });
}

/*----------------*/

export function debugAnimations() {
  debugAnimations1();
}
