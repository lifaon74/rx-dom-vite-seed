import { debounceTime$$, IObservable, IObserver, ISource, let$$, map$$, merge, single } from '@lirx/core';
import {
  compileReactiveHTMLAsComponentTemplate,
  compileStyleAsComponentStyle,
  createComponent, IGenericComponent,
  VirtualCustomElementNode, VirtualDOMNode,
} from '@lirx/dom';
import { IMatIconsListItem, MAT_ICONS_LIST } from '@lirx/mdi';
import { MatDualRingLoaderComponent } from '../material/components/loaders/dual-ring-loader/mat-dual-ring-loader.component';
import { INPUT_VALUE_MODIFIER } from '../material/modifiers/input-value.modifier';
import { NODE_REFERENCE_MODIFIER } from '../material/modifiers/node-reference.modifier';

// @ts-ignore
import html from './mat-icons-demo.component.html?raw';
// @ts-ignore
import style from './mat-icons-demo.component.scss?inline';

/** COMPONENT **/

interface IIcon {
  readonly componentTagName: string;
  readonly componentName: string;
  readonly $containerRef: IObserver<VirtualDOMNode>;
  // readonly content$: IObservable<IDefaultNotificationsUnion<IGenericGenericVirtualCustomElementNode>>;
}

interface IData {
  readonly $inputValue$: ISource<string>;
  readonly icons$: IObservable<readonly IIcon[]>;
  readonly count$: IObservable<number>;
  readonly total$: IObservable<number>;
}

export interface IMatIconsDemoComponentConfig {
  element: HTMLElement;
  data: IData;
}

export const MatIconsDemoComponent = createComponent<IMatIconsDemoComponentConfig>({
  name: 'mat-icons-demo',
  template: compileReactiveHTMLAsComponentTemplate({
    html,
    customElements: [
      MatDualRingLoaderComponent,
    ],
    modifiers: [
      INPUT_VALUE_MODIFIER,
      NODE_REFERENCE_MODIFIER,
    ],
  }),
  styles: [compileStyleAsComponentStyle(style)],
  init: (node: VirtualCustomElementNode<IMatIconsDemoComponentConfig>): IData => {
    const $inputValue$ = let$$<string>('');

    const { subscribe: inputValue$ } = $inputValue$;

    const inputValueDebounced$ = debounceTime$$(inputValue$, 500);

    const allIcons = MAT_ICONS_LIST.map(([fileName, componentTagName, componentName]: IMatIconsListItem): IIcon => {

      const loadComponent = (): Promise<IGenericComponent> => {
          return import('@lirx/mdi')
          // return import(`@lirx/mdi/src/icons/${fileName}.mjs`)
          //   .finally(() => new Promise(_ => setTimeout(_, 1000)))
            .then(_ => _[componentName] as IGenericComponent);
      };

      // const content$ = fromPromiseFactory<IGenericGenericVirtualCustomElementNode>(() => {
      //   return import('@lirx/mdi')
      //     // .finally(() => sleep(1000))
      //     .then(_ => createDocumentFragmentFilledWithNodes([new (_[componentName] as ICustomElementConstructor)]));
      //   // return import(`@lirx/mdi/src/icons/${fileName}`)
      //   //   .finally(() => sleep(1000))
      //   //   .then(_ => createDocumentFragmentFilledWithNodes([new (_ as ICustomElementConstructor)]));
      // });

      const $containerRef = (
        container: VirtualDOMNode,
      ): void => {
        loadComponent()
          .then((component: IGenericComponent) => {
            component.create().attach(container);
          });
      };

      return {
        componentTagName,
        componentName,
        $containerRef,
        // content$,
      };
    });

    const icons$ = map$$(inputValueDebounced$, (inputValue: string): IIcon[] => {
      inputValue = inputValue.trim().toLowerCase();
      return allIcons
        .filter((icon: IIcon): boolean => {
          return icon.componentTagName.toLowerCase().includes(inputValue);
        })
        .slice(0, 100);
    });

    const count$ = merge([single(0), map$$(icons$, _ => _.length)]);
    const total$ = single(allIcons.length);

    return {
      $inputValue$,
      icons$,
      count$,
      total$,
    };
  },
});
