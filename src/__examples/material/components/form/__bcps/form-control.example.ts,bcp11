import { math_floor, math_max, math_min } from '@lifaon/math';
import {
  $$distinct,
  $log,
  createMulticastReplayLastSource,
  function$$,
  IObservable,
  IObserver,
  mapDistinct$$,
  readObservableValue,
  single,
  switchMap$$,
  UNABLE_TO_READ_OBSERVABLE,
} from '@lirx/core';
import { INullish, isNullish, TupleTypes, UnionToIntersection } from '@lirx/utils';

/*------------------------------*/

export type IConstraintTestFunctionResult<GProperties extends object> = (keyof GProperties)[];

export interface IConstraintTestFunction<GValue, GProperties extends object> {
  (
    value: GValue,
  ): IConstraintTestFunctionResult<GProperties>;
}

export interface IConstraint<GValue, GProperties extends object> {
  readonly test: IConstraintTestFunction<GValue, GProperties>;
  readonly properties: GProperties;
}

export type IGenericConstraint = IConstraint<any, any>;

export function constraint<GValue, GProperties extends object>(
  test: IConstraintTestFunction<GValue, GProperties>,
  properties: GProperties,
): IConstraint<GValue, GProperties> {
  return {
    test,
    properties,
  };
}

export type InferGroupConstraintsValue<GConstraints extends readonly IGenericConstraint[]> = TupleTypes<{
  [GKey in keyof GConstraints]: GConstraints[GKey] extends IConstraint<infer GValue, any>
    ? GValue
    : never;
}>;

export type InferGroupConstraintsProperties<GConstraints extends readonly IGenericConstraint[]> = Extract<
  UnionToIntersection<
    TupleTypes<{
      [GKey in keyof GConstraints]: GConstraints[GKey] extends IConstraint<any, Partial<infer GProperties>>
        ? GProperties
        : object;
    }>
  >,
  object
>;

export function groupConstraints<GConstraints extends readonly IGenericConstraint[]>(
  ...constraints: GConstraints,
  mode: 'sequential' | 'parallel' = 'sequential',
): IConstraint<InferGroupConstraintsValue<GConstraints>, InferGroupConstraintsProperties<GConstraints>> {
  type GValue = InferGroupConstraintsValue<GConstraints>;
  type GProperties = InferGroupConstraintsProperties<GConstraints>;

  const properties: GProperties = {} as any;

  for (let i = 0, l = constraints.length; i < l; i++) {
    Object.assign(properties, constraints[i].properties);
  }

  const getTestFunction = (): IConstraintTestFunction<GValue, GProperties> => {
    switch (mode) {
      case 'sequential':
        return (value: GValue): IConstraintTestFunctionResult<GProperties> => {
          return constraints.reduce((errors: IConstraintTestFunctionResult<GProperties>, { test }: IConstraint<GValue, GProperties>): IConstraintTestFunctionResult<GProperties> => {
            return (errors.length === 0)
              ? test(value)
              : errors;
          }, []);
        };
      case 'parallel':
        return (value: GValue): IConstraintTestFunctionResult<GProperties> => {
          return constraints.flatMap(({ test }: IConstraint<GValue, GProperties>): IConstraintTestFunctionResult<GProperties> => {
            return test(value);
          });
        };
    }
  };

  return constraint<GValue, GProperties>(
    getTestFunction(),
    properties,
  );
}

export interface IRequiredConstraintProperties {
  required: boolean;
}

export function requiredConstraint<GValue, GProperties extends object>(
  required: boolean,
  {
    test,
    properties,
  }: IConstraint<GValue, GProperties>,
): IConstraint<GValue | INullish, GProperties & IRequiredConstraintProperties> {
  return constraint<GValue | INullish, GProperties & IRequiredConstraintProperties>(
    (value: GValue | INullish): IConstraintTestFunctionResult<GProperties & IRequiredConstraintProperties> => {
      return isNullish(value)
        ? (required ? ['required'] : [])
        : test(value);
    },
    {
      ...properties,
      required,
    },
  );
}

export interface IMinLengthConstraintProperties {
  minLength: number;
}

export function minLengthConstraint(
  minLength: number,
): IConstraint<string, IMinLengthConstraintProperties> {
  return constraint<string, IMinLengthConstraintProperties>(
    (value: string): IConstraintTestFunctionResult<IMinLengthConstraintProperties> => {
      return (value.length < minLength)
        ? ['minLength']
        : [];
    },
    {
      minLength,
    },
  );
}

export interface IMaxLengthConstraintProperties {
  maxLength: number;
}

export function maxLengthConstraint(
  maxLength: number,
): IConstraint<string, IMaxLengthConstraintProperties> {
  return constraint<string, IMaxLengthConstraintProperties>(
    (value: string): IConstraintTestFunctionResult<IMaxLengthConstraintProperties> => {
      return (value.length > maxLength)
        ? ['maxLength']
        : [];
    },
    {
      maxLength,
    },
  );
}

export interface IFormInputTextConstraintProperties extends //
  IRequiredConstraintProperties,
  IMinLengthConstraintProperties,
  IMaxLengthConstraintProperties
  //
{
}

export type IFormInputTextConstraintOptions = Partial<IFormInputTextConstraintProperties>;

export function formInputTextConstraint(
  {
    required = false,
    // pattern,
    minLength = 0,
    // maxLength,
    ...options
  }: IFormInputTextConstraintOptions = {},
): IConstraint<string | INullish, IFormInputTextConstraintProperties> {
  const a = groupConstraints(
    minLengthConstraint(minLength),
    maxLengthConstraint(minLength),
  );
  return requiredConstraint<string, IMinLengthConstraintProperties & IMaxLengthConstraintProperties>(
    required,
    groupConstraints([
      minLengthConstraint(minLength),
      maxLengthConstraint(minLength),
    ]),
  );
  // const constraints: Constraint<string>[] = [];
  // if (pattern !== void 0) {
  //   constraints.push(
  //     new StringPatternConstraint(pattern),
  //   );
  // }
  //
  // if (
  //   (minLength !== void 0)
  //   || (maxLength !== void 0)
  // ) {
  //   constraints.push(
  //     new StringLengthConstraint({
  //       min: minLength!,
  //       max: maxLength!,
  //     }),
  //   );
  // }
  //
  // return formInputConstraint<string>(
  //   options,
  //   new GroupedConstraint(constraints),
  // );
}

// export function required<GValue, GProperties extends object>(
//   {
//     test,
//     properties,
//   }: IConstraint<GValue, GProperties>,
//   required: boolean,
// ): IConstraint<GValue | INullish, GProperties & IRequiredConstraintProperties> {
//   return constraint<GValue | INullish, GProperties & IRequiredConstraintProperties>(
//     (value: GValue | INullish): boolean => {
//       if (required) {
//         return isNullish(value)
//
//       }
//     },
//     {
//       ...properties,
//       required,
//     },
//   );
// }

export interface IConstraintReducerFunction<GData> {
  (
    constraint: IGenericConstraint,
    data: GData,
  ): GData;
}

export class Constraint<GValue> {
  static get none(): Constraint<any> {
    if (NO_CONSTRAINT === void 0) {
      NO_CONSTRAINT = new Constraint<any>(() => true);
    }
    return NO_CONSTRAINT;
  }

  static testMany<GValue>(
    constraints: readonly Constraint<GValue>[],
  ): boolean {

  }

  readonly test: IConstraintTestFunction<GValue>;
  readonly children: readonly Constraint<GValue>[];

  constructor(
    test: IConstraintTestFunction<GValue>,
    children: readonly Constraint<GValue>[] = [],
  ) {
    this.test = test;
    this.children = children;
  }

  // test(
  //   value: GValue,
  // ): boolean {
  //   return this._test(value) && this.children.every((child: Constraint<GChildValue>): boolean => {
  //     return child.test(value);
  //   });
  // }

  reduce<GData>(
    reducer: IConstraintReducerFunction<GData>,
    data: GData,
  ): GData {
    return this.children.reduce((data: GData, child: IGenericConstraint): GData => {
      return child.reduce(reducer, data);
    }, reducer(this, data));
  }
}

export class RequiredConstraint<GValue> extends Constraint<GValue | INullish, GValue> {
  readonly required: boolean;

  constructor(
    required: boolean,
    children?: readonly Constraint<GValue>[],
  ) {
    if (required) {
      super(
        (value: GValue | INullish): value is GValue => {
          return !isNullish(value);
        },
        children,
      );
    } else {
      super(
        (value: GValue | INullish): value is GValue => {
          return isNullish(value) ||;
        },
        children,
      );
    }
    this.required = required;
  }
}

export class StringPatternConstraint extends Constraint<string> {
  readonly pattern: RegExp;

  constructor(
    pattern: RegExp,
  ) {
    super(
      (value: string): boolean => {
        pattern.lastIndex = 0;
        return pattern.test(value);
      },
    );
    this.pattern = pattern;
  }
}

export interface IStringLengthConstraintOptions {
  min?: number;
  max?: number;
}

export class StringLengthConstraint extends Constraint<string> {
  readonly min: number;
  readonly max: number;

  constructor(
    {
      min = 0,
      max = Number.POSITIVE_INFINITY,
    }: IStringLengthConstraintOptions,
  ) {
    min = math_floor(math_max(0, min));
    max = math_max(min, math_floor(max));

    super(
      (value: string): boolean => {
        return (min <= value.length)
          && (value.length <= max);
      },
    );

    this.min = min;
    this.max = max;
  }
}

export class IsNumberConstraint extends Constraint<number> {
  constructor() {
    super(
      (value: number): boolean => {
        return !Number.isNaN(value);
      },
    );
  }
}

export interface INumberRangeConstraintOptions {
  min?: number;
  max?: number;
  step?: number;
}

export class NumberRangeConstraint extends Constraint<number> {
  readonly min: number;
  readonly max: number;
  readonly step: number;

  constructor(
    {
      min = Number.NEGATIVE_INFINITY,
      max = Number.POSITIVE_INFINITY,
      step = 0,
    }: INumberRangeConstraintOptions,
  ) {
    step = math_max(0, step);

    super(
      (value: number): boolean => {
        if (
          (min <= value)
          && (value <= max)
        ) {
          if (step === 0) {
            return true;
          } else {
            const start: number = Number.isFinite(min)
              ? min
              : 0;
            const v: number = ((value - start) / step);
            return Math.trunc(v) === v;
          }
        } else {
          return false;
        }
      },
    );

    this.min = min;
    this.max = max;
    this.step = step;
  }
}

/*------------------------------*/

export interface IFormInputConstraintOptions {
  required?: boolean;
}

export function formInputConstraint<GValue>(
  {
    required = false,
  }: IFormInputConstraintOptions = {},
  constraint: Constraint<GValue>,
): Constraint<GValue | INullish> {
  return new RequiredConstraint<GValue>(
    constraint,
    required,
  );
}

// export function formInputTextConstraint(
//   {
//     pattern,
//     minLength,
//     maxLength,
//     ...options
//   }: IFormInputTextConstraintOptions = {},
// ): Constraint<string | INullish> {
//   const constraints: Constraint<string>[] = [];
//   if (pattern !== void 0) {
//     constraints.push(
//       new StringPatternConstraint(pattern),
//     );
//   }
//
//   if (
//     (minLength !== void 0)
//     || (maxLength !== void 0)
//   ) {
//     constraints.push(
//       new StringLengthConstraint({
//         min: minLength!,
//         max: maxLength!,
//       }),
//     );
//   }
//
//   return formInputConstraint<string>(
//     options,
//     new GroupedConstraint(constraints),
//   );
// }

export interface IFormInputNumberConstraintOptions extends IFormInputConstraintOptions {
  min?: number;
  max?: number;
  step?: number;
}

export function formInputNumberConstraint(
  {
    min,
    max,
    step,
    ...options
  }: IFormInputNumberConstraintOptions = {},
): Constraint<number | INullish> {
  const constraints: Constraint<number>[] = [];

  if (
    (min !== void 0)
    || (max !== void 0)
    || (step !== void 0)
  ) {
    constraints.push(
      new NumberRangeConstraint({
        min,
        max,
        step,
      }),
    );
  }

  return formInputConstraint<number>(
    options,
    new IsNumberConstraint(),
    new GroupedConstraint(constraints),
  );
}

/*------------------------------*/

function isRequired(
  constraint: IGenericConstraint,
): boolean {
  return constraint.reduce((constraint: IGenericConstraint, required: boolean): boolean => {
    return required
      || (
        (constraint instanceof RequiredConstraint)
        && constraint.required
      );
  }, false);
}

function getPattern(
  constraint: IGenericConstraint,
): RegExp | null {
  return constraint.reduce((constraint: IGenericConstraint, pattern: RegExp | null): RegExp | null => {
    return (pattern === null)
      ? (
        (constraint instanceof StringPatternConstraint)
          ? constraint.pattern
          : null
      )
      : pattern;
  }, null);
}

function getMinLength(
  constraint: IGenericConstraint,
): number {
  return constraint.reduce((constraint: IGenericConstraint, minLength: number): number => {
    return (constraint instanceof StringLengthConstraint)
      ? math_max(minLength, constraint.min)
      : minLength;
  }, 0);
}

function getMaxLength(
  constraint: IGenericConstraint,
): number {
  return constraint.reduce((constraint: IGenericConstraint, maxLength: number): number => {
    return (constraint instanceof StringLengthConstraint)
      ? math_min(maxLength, constraint.max)
      : maxLength;
  }, 0);
}

/*------------------------------*/

export type IFormInputValue<GValue> = GValue | null;
export type IFormInputConstraint<GValue> = Constraint<IFormInputValue<GValue>>;

export interface IFormInputOptions<GValue> {
  value?: IFormInputValue<GValue>;
  disabled?: boolean;
  constraint?: IFormInputConstraint<GValue>;
}

export class FormInput<GName extends string, GValue> {
  protected readonly _name: GName;

  protected readonly _value$: IObservable<IFormInputValue<GValue>>;
  protected readonly _$value: IObserver<IFormInputValue<GValue>>;

  protected readonly _disabled$: IObservable<boolean>;
  protected readonly _$disabled: IObserver<boolean>;

  protected readonly _constraintWithDisabled$: IObservable<IFormInputConstraint<GValue>>;
  protected readonly _$constraint: IObserver<IFormInputConstraint<GValue>>;

  protected readonly _isValid$: IObservable<boolean>; // computed
  protected readonly _required$: IObservable<boolean>; // computed

  constructor(
    name: GName,
    {
      value = null,
      disabled = false,
      constraint = NoConstraint.shared,
    }: IFormInputOptions<GValue> = {},
  ) {
    this._name = name;

    /* VALUE */

    const $value$ = createMulticastReplayLastSource<IFormInputValue<GValue>>(value);

    const value$ = $value$.subscribe;
    const $value = $$distinct($value$.emit, value);

    this._value$ = value$;
    this._$value = $value;

    /* DISABLED */

    const $disabled$ = createMulticastReplayLastSource<boolean>(disabled);

    const disabled$ = $disabled$.subscribe;
    const $disabled = $$distinct($disabled$.emit, disabled);

    this._disabled$ = disabled$;
    this._$disabled = $disabled;

    /* CONSTRAINT */

    const $constraint$ = createMulticastReplayLastSource<IFormInputConstraint<GValue>>(constraint);

    const constraint$ = $constraint$.subscribe;
    const $constraint = $constraint$.emit;

    const constraintWithDisabled$ = switchMap$$(disabled$, (disabled: boolean): IObservable<IFormInputConstraint<GValue>> => {
      return disabled
        ? single(NoConstraint.shared)
        : constraint$;
    });

    this._constraintWithDisabled$ = constraintWithDisabled$;
    this._$constraint = $constraint;

    /* IS VALID */

    const isValid$ = function$$(
      [constraintWithDisabled$, value$],
      (constraintWithDisabled: IFormInputConstraint<GValue>, value: IFormInputValue<GValue>): boolean => {
        return constraintWithDisabled.test(value);
      });

    this._isValid$ = isValid$;

    /* REQUIRED */

    const required$ = mapDistinct$$(constraint$, isRequired);

    this._required$ = required$;
  }

  /* NAME */

  get name(): GName {
    return this._name;
  }

  /* VALUE */

  get value(): IFormInputValue<GValue> {
    return readObservableValue(
      this._value$,
      UNABLE_TO_READ_OBSERVABLE,
    );
  }

  set value(
    input: IFormInputValue<GValue>,
  ) {
    this._$value(input);
  }

  get value$(): IObservable<IFormInputValue<GValue>> {
    return this._value$;
  }

  get $value(): IObserver<IFormInputValue<GValue>> {
    return this._$value;
  }

  /* DISABLED */

  get disabled(): boolean {
    return readObservableValue(
      this._disabled$,
      UNABLE_TO_READ_OBSERVABLE,
    );
  }

  set disabled(
    input: boolean,
  ) {
    this._$disabled(input);
  }

  get disabled$(): IObservable<boolean> {
    return this._disabled$;
  }

  get $disabled(): IObserver<boolean> {
    return this._$disabled;
  }

  /* CONSTRAINT */

  get constraint(): IFormInputConstraint<GValue> {
    return readObservableValue(
      this._constraintWithDisabled$,
      UNABLE_TO_READ_OBSERVABLE,
    );
  }

  set constraint(
    input: IFormInputConstraint<GValue>,
  ) {
    this._$constraint(input);
  }

  get constraint$(): IObservable<IFormInputConstraint<GValue>> {
    return this._constraintWithDisabled$;
  }

  get $constraint(): IObserver<IFormInputConstraint<GValue>> {
    return this._$constraint;
  }

  /* VALIDITY */

  get isValid$(): IObservable<boolean> {
    return this._isValid$;
  }

  /* REQUIRED */

  get required$(): IObservable<boolean> {
    return this._required$;
  }

  /* METHODS */

  reset(): void {
    this._$value(null);
  }
}

export type IGenericFormInput = FormInput<string, any>;

/*----*/

export interface IFormInputTextOptions extends IFormInputOptions<string> {
}

export class FormInputText<GName extends string> extends FormInput<GName, string> {
  constructor(
    name: GName,
    options?: IFormInputTextOptions,
  ) {
    super(name, options);
  }
}

/*----*/

export interface IFormInputNumberOptions extends IFormInputOptions<number> {
}

export class FormInputNumber<GName extends string> extends FormInput<GName, number> {
  constructor(
    name: GName,
    options?: IFormInputNumberOptions,
  ) {
    super(name, options);
  }
}

/*------------------------------*/

/*------------------------------*/

function debug() {
  function constraint() {
    if (min < value && value < max) {

    }
  }

  function constraintA(value: number | null) {
    if (isNullish(value)) {
      throw 'required';
    } else {
      if (inRange(value, 0, 5)) {
        return true;
      } else {
        throw 'out-of-range';
      }
    }
  }

  function constraintB(value: number | null) {
    if (isNullish(value)) {
      return true;
    } else {
      if (inRange(value, 0, 5)) {

      }
    }
  }

  function required(value: GValue | INullish): any {

  }

  function constraintC(value: number | null) {
    return required(value, () => {

    });
    if (isNullish(value)) {
      return true;
    } else {
      if (inRange(value, 0, 5)) {

      }
    }
  }

}

async function formControlExample1() {
  const stringConstraint = () => {
    const constraint = new RequiredConstraint(
      new StringPatternConstraint(/.+/),
      true,
    );

    console.log(constraint.test('a'));
    console.log(constraint.test(''));
    console.log(constraint.test(null));
    // console.log(constraint.test(4));

    console.log(isRequired(constraint));
  };

  const numberConstraint = () => {
    const constraint = new NumberRangeConstraint({
      step: 0.2,
    });

    console.log(constraint.test(4.2));
  };

  // stringConstraint();
  numberConstraint();
}

async function formControlExample2() {
  const inputText = new FormInputText('abc', {
    constraint: formInputTextConstraint({
      pattern: /.+/,
      required: false,
    }),
  });

  inputText.isValid$($log);
  (window as any).inputText = inputText;
}

async function formControlExample3() {
  const inputNumber = new FormInputNumber('abc', {
    constraint: formInputNumberConstraint({
      min: 0,
      max: 10,
      step: 1,
    }),
  });

  inputNumber.isValid$($log);
  (window as any).inputNumber = inputNumber;
}

/*------------------------------*/

export async function formControlExample() {
  await formControlExample1();
  // await formControlExample2();
}
