import { INullish, IObservable, isNullish, map$$, single } from '@lirx/core';
import { compileReactiveHTMLAsComponentTemplate, compileStyleAsComponentStyle, createComponent, VirtualCustomElementNode } from '@lirx/dom';
import { IconCloseComponent, IconPauseComponent, IconPlayComponent } from '@lirx/mdi';
import { MatIconButtonComponent } from '../../../../../../material/components/buttons/icon/mat-icon-button.component';

// @ts-ignore
import html from './async-task.component.html?raw';
// @ts-ignore
import style from './async-task.component.scss?inline';



/*---*/

export type IAppAsyncTaskComponentState =
  | 'running'
  | 'running-and-pausable'
  | 'paused'
  | 'complete'
  | 'errored'
;

/**
 * COMPONENT: 'app-async-task'
 */

// export const APP_ASYNC_TASK_COMPONENT_PROGRESS_ERROR = -2;
// export const APP_ASYNC_TASK_COMPONENT_PROGRESS_UNDETERMINED = -1;

interface IData {
  readonly name$: IObservable<string>;
  readonly hasMessage$: IObservable<boolean>;
  readonly message$: IObservable<string>;
  readonly progressPercent$: IObservable<string | null>;
  readonly progressTitle$: IObservable<string>;
}

interface IAppAsyncTaskComponentConfig {
  element: HTMLElement;
  inputs: [
    ['name', string],
    ['message', string],
    ['progress', number],
    ['state', IAppAsyncTaskComponentState],
  ];
  data: IData;
}

export const AppAsyncTaskComponent = createComponent<IAppAsyncTaskComponentConfig>({
  name: 'app-async-task',
  template: compileReactiveHTMLAsComponentTemplate({
    html,
    customElements: [
      IconPauseComponent,
      IconPlayComponent,
      IconCloseComponent,
      MatIconButtonComponent,
    ],
  }),
  styles: [compileStyleAsComponentStyle(style)],
  inputs: [
    ['name'],
    ['message', ''],
    ['progress', 0],
    ['state', 'running'],
  ],
  init: (node: VirtualCustomElementNode<IAppAsyncTaskComponentConfig>): IData => {
    const name$ = node.inputs.get$('name');
    const message$ = node.inputs.get$('message');
    const paused$ = node.inputs.get$('paused');
    const progress$ = node.inputs.get$('progress');

    const hasMessage$ = map$$(message$, (message: string): boolean => (message !== ''));

    const progressPercent$ = map$$(progress$, (progress: number): string | null => {
      if (progress === APP_ASYNC_TASK_COMPONENT_PROGRESS_ERROR) {
        return null;
      } else if (progress === APP_ASYNC_TASK_COMPONENT_PROGRESS_UNDETERMINED) {
        return null;
      } else {
        return `${progress * 100}%`;
      }
    });

    const progressTitle$ = map$$(progress$, (progress: number): string => {
      if (progress === APP_ASYNC_TASK_COMPONENT_PROGRESS_ERROR) {
        return '';
      } else if (progress === APP_ASYNC_TASK_COMPONENT_PROGRESS_UNDETERMINED) {
        return '';
      } else {
        return `${Math.floor(progress * 100)}%`;
      }
    });

    const errored$ = map$$(progress$, (progress: number): boolean => (progress === APP_ASYNC_TASK_COMPONENT_PROGRESS_ERROR));
    const undetermined$ = map$$(progress$, (progress: number): boolean => (progress === APP_ASYNC_TASK_COMPONENT_PROGRESS_UNDETERMINED));
    const complete$ = map$$(progress$, (progress: number): boolean => (progress >= 1));
    const pausable$ = map$$(paused$, (paused: boolean | INullish): boolean => !isNullish(paused));

    node.setReactiveClass('pausable', pausable$);
    node.setReactiveClass('paused', paused$);
    node.setReactiveClass('errored', errored$);
    node.setReactiveClass('undetermined', undetermined$);
    node.setReactiveClass('complete', complete$);

    return {
      name$,
      hasMessage$,
      message$,
      progressPercent$,
      progressTitle$,
    };
  },
});

