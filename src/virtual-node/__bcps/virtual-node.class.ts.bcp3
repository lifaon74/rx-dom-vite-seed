import { IMulticastReplayLastSource, let$$ } from '@lirx/core';

export type IVirtualNodeOrNull = VirtualNode | null;

export abstract class VirtualNode {

  protected _$parentNode$: IMulticastReplayLastSource<IVirtualNodeOrNull>;
  protected _previousNode: IVirtualNodeOrNull;
  protected _nextNode: IVirtualNodeOrNull;
  protected _firstChild: IVirtualNodeOrNull;
  protected _lastChild: IVirtualNodeOrNull;

  protected constructor() {
    this._$parentNode$ = let$$<IVirtualNodeOrNull>(null);
    this._previousNode = null;
    this._nextNode = null;
    this._firstChild = null;
    this._lastChild = null;
  }

  get parentNode(): IVirtualNodeOrNull {
    return this._$parentNode$.getValue();
  }

  get previousNode(): IVirtualNodeOrNull {
    return this._nextNode;
  }

  get nextNode(): IVirtualNodeOrNull {
    return this._nextNode;
  }

  get firstChild(): IVirtualNodeOrNull {
    return this._firstChild;
  }

  get lastChild(): IVirtualNodeOrNull {
    return this._lastChild;
  }

  contains(
    childNode: VirtualNode,
  ): boolean {
    let node: IVirtualNodeOrNull = childNode;

    do {
      if (node === this) {
        return true;
      } else {
        node = node.parentNode;
      }
    } while (node !== null);

    return false;
  }

  insertBefore<GNode extends VirtualNode>(
    node: GNode,
    referenceNode: IVirtualNodeOrNull = null,
  ): GNode {
    return node;
  }

  removeChild<GNode extends VirtualNode>(
    node: GNode,
  ): GNode {
    if (node.parentNode === this) {
      return node;
    } else {
      throw new Error(`Not a child of this node`);
    }
    // if (this.parentNode !== null) {
    //   if (this._previousNode === null) { // current node is first child
    //     this.parentNode._firstChild = this._nextNode;
    //   } else {
    //     this._previousNode._nextNode = this._nextNode;
    //   }
    //
    //   if (this._nextNode === null) { // current node is last child
    //     this.parentNode._lastChild = this._previousNode;
    //   } else {
    //     this._nextNode._previousNode = this._previousNode;
    //   }
    //
    //   this._previousNode = null;
    //   this._nextNode = null;
    //   this._$parentNode$.emit(null);
    // }

  }

  * getChildren(): Generator<VirtualNode> {
    let node: IVirtualNodeOrNull = this._firstChild;
    while (node !== null) {
      yield node;
      node = node._nextNode;
    }
  }
}


/*-----------------*/



export abstract class VirtualDOMChildNode<GNode extends ParentNode> extends VirtualNode {
  public readonly node: GNode;

  protected constructor(
    node: GNode,
  ) {
    super();
    this.node = node;
  }


  override insertBefore<GNode extends VirtualNode>(
    node: GNode,
    referenceNode: IVirtualNodeOrNull = null,
  ): GNode {
    super.insertBefore<GNode>(
      node,
      referenceNode,
    );

    this.node.insertBefore()

    return node;
  }

}

/*-----------------*/


export abstract class VirtualDOMParentNode<GNode extends ParentNode> extends VirtualNode {
  public readonly node: GNode;

  protected constructor(
    node: GNode,
  ) {
    super();
    this.node = node;
  }


  override insertBefore<GNode extends VirtualNode>(
    node: GNode,
    referenceNode: IVirtualNodeOrNull = null,
  ): GNode {
    super.insertBefore<GNode>(
      node,
      referenceNode,
    );

    this.node.insertBefore()

    return node;
  }

}


// /*-------------*/
//
// export class VirtualTextNode extends VirtualNode {
//   public value: string;
//
//   constructor(
//     value: string = '',
//   ) {
//     super();
//     this.value = value;
//   }
// }
//
// /*-------------*/
//

//
// /*-------------*/
//
// export class DOMTextNode extends VirtualDOMNode<Text> {
//
//   constructor(
//     value?: string,
//   ) {
//     super(new Text(value));
//   }
//
//   get value(): string {
//     return this.node.data;
//   }
//
//   set value(
//     input: string,
//   ) {
//     this.node.data = input;
//   }
// }


export function checkVirtualNodeConsistency(
  node: VirtualNode,
): void {
  if (node.parentNode === null) {
    if (node.previousNode !== null) {
      throw new Error(`(node.parentNode === null) && (node.previousNode !== null)`);
    }
    if (node.nextNode !== null) {
      throw new Error(`(node.parentNode === null) && (node.nextNode !== null)`);
    }
  }
}

