import { IMulticastReplayLastSource, let$$ } from '@lirx/core';

export type IVirtualNodeOrNull = VirtualNode | null;

export abstract class VirtualNode {

  protected _$parentNode$: IMulticastReplayLastSource<IVirtualNodeOrNull>;
  protected _previousNode: IVirtualNodeOrNull;
  protected _nextNode: IVirtualNodeOrNull;
  protected _firstChild: IVirtualNodeOrNull;
  protected _lastChild: IVirtualNodeOrNull;

  protected constructor() {
    this._$parentNode$ = let$$<IVirtualNodeOrNull>(null);
    this._previousNode = null;
    this._nextNode = null;
    this._firstChild = null;
    this._lastChild = null;
  }

  get parentNode(): IVirtualNodeOrNull {
    return this._$parentNode$.getValue();
  }

  get previousNode(): IVirtualNodeOrNull {
    return this._nextNode;
  }

  get nextNode(): IVirtualNodeOrNull {
    return this._nextNode;
  }

  get firstChild(): IVirtualNodeOrNull {
    return this._firstChild;
  }

  get lastChild(): IVirtualNodeOrNull {
    return this._lastChild;
  }

  contains(
    childNode: VirtualNode,
  ): boolean {
    let node: IVirtualNodeOrNull = childNode;

    do {
      if (node === this) {
        return true;
      } else {
        node = node.parentNode;
      }
    } while (node !== null);

    return false;
  }

  attach(
    parentNode: VirtualNode,
    referenceNode: IVirtualNodeOrNull = null,
  ): boolean {

    if (this.contains(parentNode)) {
      throw new Error(`current node already contains parentNode`);
    }

    if (referenceNode === null) {
      if (
        (this.parentNode === parentNode)
        && (this.parentNode._lastChild === this) // current node is already the last child of parentNode, so we have nothing to do
      ) {
        return false;
      }
    } else {
      if (this._nextNode === referenceNode) { // current node is already before referenceNode, so we have nothing to do
        return false;
      }

      if (referenceNode.parentNode !== parentNode) {
        throw new Error(`referenceNode must have parentNode as parent`);
      }
    }

    // detach current node
    if (this.parentNode !== null) {
      if (this._previousNode === null) { // current node is first child
        this.parentNode._firstChild = this._nextNode;
      } else {
        this._previousNode._nextNode = this._nextNode;
      }

      if (this._nextNode === null) { // current node is last child
        this.parentNode._lastChild = this._previousNode;
      } else {
        this._nextNode._previousNode = this._previousNode;
      }
    }

    this._nextNode = referenceNode;

    if (referenceNode === null) {
      this._previousNode = parentNode._lastChild;

      if (parentNode._lastChild === null) { // empty list
        parentNode._firstChild = this;
        parentNode._lastChild = this;
      } else {
        parentNode._lastChild._nextNode = this;
        parentNode._lastChild = this;
      }
    } else {
      this._previousNode = referenceNode._previousNode;

      if (referenceNode._previousNode === null) { // referenceNode is first child
        parentNode._firstChild = this;
      } else {
        referenceNode._previousNode._nextNode = this;
      }

      referenceNode._previousNode = this;
    }

    this._$parentNode$.emit(parentNode);

    return true;
  }

  detach(): boolean {
    if (this.parentNode === null) {
      return false;
    } else {
      if (this._previousNode === null) { // current node is first child
        this.parentNode._firstChild = this._nextNode;
      } else {
        this._previousNode._nextNode = this._nextNode;
      }

      if (this._nextNode === null) { // current node is last child
        this.parentNode._lastChild = this._previousNode;
      } else {
        this._nextNode._previousNode = this._previousNode;
      }

      this._previousNode = null;
      this._nextNode = null;
      this._$parentNode$.emit(null);
      return true;
    }
  }

  * getChildren(): Generator<VirtualNode> {
    let node: IVirtualNodeOrNull = this._firstChild;
    while (node !== null) {
      yield node;
      node = node._nextNode;
    }
  }
}

/*-------------*/

// export abstract class VirtualDOMNode<GNode extends Node> extends VirtualNode {
//   public readonly node: GNode;
//
//   protected constructor(
//     node: GNode,
//   ) {
//     super();
//     this.node = node;
//   }
//
//   getParentVirtualDOMNode<GNode extends VirtualDOMNode<Node>>(): GNode | null {
//     let node: IVirtualNodeOrNull = this.parentNode;
//     while (node !== null) {
//       if (node instanceof VirtualDOMNode) {
//         return node as GNode;
//       }
//     }
//     return null;
//   }
// }

/*-------------*/

// export abstract class VirtualDOMParentNode<GNode extends ParentNode> extends VirtualDOMNode<GNode> {
//   protected constructor(
//     node: GNode,
//   ) {
//     super(node);
//   }
//
//
//   override attach(
//     parentNode: VirtualNode,
//     referenceNode?: IVirtualNodeOrNull,
//   ): void {
//     super.attach(
//       parentNode,
//       referenceNode,
//     );
//     if (this.node.parentNode !== null) {
//       parentNode.insert(this.node);
//     }
//   }
//
//   override detach(): void {
//     super.detach();
//     if (this.node.parentNode !== null) {
//       this.node.parentNode.removeChild(this.node);
//     }
//   }
// }
//
// /*-------------*/
//
// export abstract class VirtualDOMChildNode<GNode extends ChildNode> extends VirtualNode {
//   public readonly node: GNode;
//
//   protected constructor(
//     node: GNode,
//   ) {
//     super();
//     this.node = node;
//   }
//
//
//   override attach(
//     parentNode: VirtualNode,
//     referenceNode?: IVirtualNodeOrNull,
//   ): void {
//     super.attach(
//       parentNode,
//       referenceNode,
//     );
//     if (this.node.parentNode !== null) {
//       parentNode.insert(this.node);
//     }
//   }
//
//   override detach(): void {
//     super.detach();
//     if (this.node.parentNode !== null) {
//       this.node.parentNode.removeChild(this.node);
//     }
//   }
// }

/*-------------*/

export abstract class VirtualDOMNode extends VirtualNode {
  abstract getDOMReference(): Node;

  // abstract getDOMParent(): ParentNode | null;

  getParentVirtualDOMNode(): VirtualDOMNode | null {
    let node: IVirtualNodeOrNull = this.parentNode;
    while (node !== null) {
      if (node instanceof VirtualDOMNode) {
        return node;
      }
    }
    return null;
  }

  getParentVirtualDOMNodeOrThrow(): VirtualDOMNode {
    const parentVirtualDOMNode: VirtualDOMNode | null = this.getParentVirtualDOMNode();
    if (parentVirtualDOMNode === null) {
      throw new Error(`Cannot locate a parentVirtualDOMNode`);
    } else {
      return parentVirtualDOMNode;
    }
  }

  override attach(
    parentNode: VirtualNode,
    referenceNode: IVirtualNodeOrNull = null,
  ): boolean {
    const attached: boolean = super.attach(
      parentNode,
      referenceNode,
    );

    if (attached) {
      const selfDOMReference: Node = this.getDOMReference();
      let referenceDOMReference: Node | null;

      if (referenceNode === null) {
        referenceDOMReference = null;
      } else if (referenceNode instanceof VirtualDOMNode) {
        referenceDOMReference = referenceNode.getDOMReference();
      } else {
        throw new Error(`referenceNode must be a VirtualDOMNode`);
      }

      const parentVirtualDOMNode: VirtualDOMNode = this.getParentVirtualDOMNodeOrThrow();
      const parentNodeDOMReference: Node = parentVirtualDOMNode.getDOMReference();
      parentNodeDOMReference.insertBefore(selfDOMReference, referenceDOMReference);
    }

    return attached;
  }

  // override detach(): boolean {
  //   const parentNode: IVirtualNodeOrNull = this.parentNode;
  //
  //   const detached: boolean = super.detach();
  //
  //   if (detached) {
  //     const selfDOMReference: Node = this.getDOMReference();
  //     const parentNodeDOMReference: ParentNode | null = selfDOMReference.parentNode;
  //
  //     if (parentNodeDOMReference === null) {
  //       throw new Error(`Cannot locate a parentNode`);
  //     } else {
  //       // TODO continue here
  //       parentNodeDOMReference.insertBefore(selfDOMReference, referenceDOMReference);
  //     }
  //
  //     if (parentNode !== null) {
  //       if (parentNode instanceof VirtualElementNode) {
  //         parentNode.elementNode.removeChild(this.elementNode);
  //       } else {
  //         throw new Error(`Unsupported parentNode`);
  //       }
  //     }
  //   }
  //
  //   return detached;
  // }
}

/*-------------*/

export class VirtualElementNode<GElementNode extends Element> extends VirtualDOMNode {

  static create<GElementNode extends Element>(
    namespaceURI: string,
    name: string,
    options?: ElementCreationOptions,
  ): VirtualElementNode<GElementNode> {
    return new VirtualElementNode<GElementNode>(
      document.createElementNS(namespaceURI, name, options) as GElementNode,
    );
  }

  public readonly elementNode: GElementNode;

  protected constructor(
    elementNode: GElementNode,
  ) {
    super();
    this.elementNode = elementNode;
  }

  override getDOMReference(): Node {
    return this.elementNode;
  }

  // override attach(
  //   parentNode: VirtualNode,
  //   referenceNode: IVirtualNodeOrNull = null,
  // ): boolean {
  //   const attached: boolean = super.attach(
  //     parentNode,
  //     referenceNode,
  //   );
  //
  //   if (attached) {
  //     if (parentNode instanceof VirtualElementNode) {
  //       if (referenceNode === null) {
  //         parentNode.elementNode.insertBefore(this.elementNode, null);
  //       } else {
  //         if (referenceNode instanceof VirtualElementNode) {
  //           parentNode.elementNode.insertBefore(this.elementNode, referenceNode.elementNode);
  //         } else if (referenceNode instanceof VirtualTextNode) {
  //           parentNode.elementNode.insertBefore(this.elementNode, referenceNode.textNode);
  //         } else {
  //           throw new Error(`Unsupported referenceNode`);
  //         }
  //       }
  //     } else {
  //       throw new Error(`Unsupported parentNode`);
  //     }
  //   }
  //
  //   return attached;
  // }
  //
  // override detach(): boolean {
  //   const parentNode: IVirtualNodeOrNull = this.parentNode;
  //
  //   const detached: boolean = super.detach();
  //
  //   if (detached) {
  //     if (parentNode !== null) {
  //       if (parentNode instanceof VirtualElementNode) {
  //         parentNode.elementNode.removeChild(this.elementNode);
  //       } else {
  //         throw new Error(`Unsupported parentNode`);
  //       }
  //     }
  //   }
  //
  //   return detached;
  // }

  // detachChildNodes(
  //   parentNode: VirtualNode,
  // ): void {
  //   if (parentNode instanceof VirtualElementNode) {
  //     parentNode.elementNode.removeChild(this.elementNode);
  //   } else {
  //     throw new Error(`Unsupported parentNode`);
  //   }
  // }
}

/*-------------*/

export class VirtualContainerNode extends VirtualNode {

  static create(
    name: string,
  ): VirtualContainerNode {
    return new VirtualContainerNode(
      name,
    );
  }

  public readonly name: string;
  public readonly startNode: Text | Comment;
  public readonly endNode: Text | Comment;

  protected constructor(
    name: string,
  ) {
    super();
    this.name = name;
    this.startNode = new Comment(`VIRTUAL-CONTAINER: ${this.name} - START`);
    this.endNode = new Comment(`VIRTUAL-CONTAINER: ${this.name} - END`);
  }

  override attach(
    parentNode: VirtualNode,
    referenceNode: IVirtualNodeOrNull = null,
  ): boolean {
    const attached: boolean = super.attach(
      parentNode,
      referenceNode,
    );

    if (attached) {
      const attachVirtualContainerNode = (
        node: VirtualContainerNode,
      ): void => {
        const parentNode: IVirtualNodeOrNull = node.parentNode;
        if (parentNode instanceof VirtualElementNode) {

          const attachVirtualContainerNodeChildrenHavingReferenceNode = (
            referenceNode: Node | null,
          ): void => {
            parentNode.elementNode.insertBefore(this.startNode, referenceNode);

            const attachVirtualContainerNodeChildren = (
              node: VirtualContainerNode,
            ): void => {
              for (const child of node.getChildren()) {
                if (child instanceof VirtualElementNode) {
                  parentNode.elementNode.insertBefore(child.elementNode, referenceNode);
                } else if (child instanceof VirtualContainerNode) {
                  attachVirtualContainerNodeChildren(child);
                } else if (child instanceof VirtualTextNode) {
                  parentNode.elementNode.insertBefore(child.textNode, referenceNode);
                } else {
                  throw new Error(`Unsupported child`);
                }
              }
            };

            attachVirtualContainerNodeChildren(this);

            parentNode.elementNode.insertBefore(this.endNode, referenceNode);
          };

          if (referenceNode === null) {
            attachVirtualContainerNodeChildrenHavingReferenceNode(null);
          } else if (referenceNode instanceof VirtualElementNode) {
            attachVirtualContainerNodeChildrenHavingReferenceNode(referenceNode.elementNode);
          } else if (referenceNode instanceof VirtualContainerNode) {
            attachVirtualContainerNodeChildrenHavingReferenceNode(referenceNode.endNode);
          } else if (referenceNode instanceof VirtualTextNode) {
            attachVirtualContainerNodeChildrenHavingReferenceNode(referenceNode.textNode);
          } else {
            throw new Error(`Unsupported referenceNode`);
          }

        } else if (parentNode instanceof VirtualContainerNode) {
          attachVirtualContainerNode(parentNode);
        } else {
          throw new Error(`Unsupported parentNode`);
        }
      };
      attachVirtualContainerNode(this);

      // if (parentNode instanceof VirtualElementNode) {
      //   if (referenceNode === null) {
      //     parentNode.elementNode.insertBefore(this.startNode, null);
      //     // for (const child of this.getChildren()) {
      //     //   if (child instanceof )
      //     // }
      //     parentNode.elementNode.insertBefore(this.startNode, null);
      //   } else {
      //     // throw new Error(`Unsupported referenceNode`);
      //     // if (referenceNode instanceof VirtualElementNode) {
      //     //   parentNode.elementNode.insertBefore(this.elementNode, referenceNode.elementNode);
      //     // } else if (referenceNode instanceof VirtualTextNode) {
      //     //   parentNode.elementNode.insertBefore(this.elementNode, referenceNode.textNode);
      //     // } else {
      //     //   throw new Error(`Unsupported referenceNode`);
      //     // }
      //   }
      // } else {
      //   throw new Error(`Unsupported parentNode`);
      // }
    }

    return attached;
  }

  override detach(): boolean {
    const parentNode: IVirtualNodeOrNull = this.parentNode;

    const detached: boolean = super.detach();

    if (detached) {
      const detachVirtualContainerNode = (
        node: VirtualContainerNode,
        parentNode: IVirtualNodeOrNull,
      ): void => {
        if (parentNode instanceof VirtualElementNode) {
          parentNode.elementNode.removeChild(this.startNode);
          parentNode.elementNode.removeChild(this.endNode);

          const detachVirtualContainerNodeChildren = (
            node: VirtualContainerNode,
          ): void => {
            for (const child of node.getChildren()) {
              if (child instanceof VirtualElementNode) {
                parentNode.elementNode.removeChild(child.elementNode);
              } else if (child instanceof VirtualContainerNode) {
                detachVirtualContainerNodeChildren(child);
              } else if (child instanceof VirtualTextNode) {
                parentNode.elementNode.removeChild(child.textNode);
              } else {
                throw new Error(`Unsupported child`);
              }
            }
          };

          detachVirtualContainerNodeChildren(node);
        } else if (parentNode instanceof VirtualContainerNode) {
          detachVirtualContainerNode(parentNode, parentNode.parentNode);
        } else {
          throw new Error(`Unsupported parentNode`);
        }
      };

      detachVirtualContainerNode(this, parentNode);
    }

    return detached;
  }

  // detachChildNodes(
  //   parentNode: VirtualNode,
  // ): void {
  //   if (parentNode instanceof VirtualElementNode) {
  //     for (const child of this.getChildren()) {
  //       if (child instanceof VirtualElementNode) {
  //         parentNode.elementNode.removeChild(this.elementNode);
  //       }
  //     }
  //   } else {
  //     throw new Error(`Unsupported parentNode`);
  //   }
  // }
}

/*-------------*/

export class VirtualTextNode extends VirtualDOMNode {
  static create(
    value?: string,
  ): VirtualTextNode {
    return new VirtualTextNode(
      new Text(value),
    );
  }

  public readonly textNode: Text;

  protected constructor(
    textNode: Text,
  ) {
    super();
    this.textNode = textNode;
  }

  get value(): string {
    return this.textNode.data;
  }

  set value(
    input: string,
  ) {
    this.textNode.data = input;
  }

  override getDOMReference(): Node {
    return this.textNode;
  }

  override getDOMParent(): ParentNode | null {
    return this.textNode.parentNode;
  }

  override attach(
    parentNode: VirtualNode,
    referenceNode: IVirtualNodeOrNull = null,
  ): boolean {
    const attached: boolean = super.attach(
      parentNode,
      referenceNode,
    );

    if (attached) {
      if (parentNode instanceof VirtualElementNode) {
        if (referenceNode === null) {
          parentNode.elementNode.insertBefore(this.textNode, null);
        } else {
          if (referenceNode instanceof VirtualElementNode) {
            parentNode.elementNode.insertBefore(this.textNode, referenceNode.elementNode);
          } else if (referenceNode instanceof VirtualContainerNode) {
            parentNode.elementNode.insertBefore(this.textNode, referenceNode.endNode);
          } else if (referenceNode instanceof VirtualTextNode) {
            parentNode.elementNode.insertBefore(this.textNode, referenceNode.textNode);
          } else {
            throw new Error(`Unsupported referenceNode`);
          }
        }
      } else if (parentNode instanceof VirtualContainerNode) {
        const _parentNode: Node | null = parentNode.endNode.parentNode;

        if (_parentNode !== null) {
          if (referenceNode === null) {
            _parentNode.insertBefore(this.textNode, null);
          } else {
            if (referenceNode instanceof VirtualElementNode) {
              _parentNode.insertBefore(this.textNode, referenceNode.elementNode);
            } else if (referenceNode instanceof VirtualContainerNode) {
              _parentNode.insertBefore(this.textNode, referenceNode.endNode);
            } else if (referenceNode instanceof VirtualTextNode) {
              _parentNode.insertBefore(this.textNode, referenceNode.textNode);
            } else {
              throw new Error(`Unsupported referenceNode`);
            }
          }
        }
      } else {
        throw new Error(`Unsupported parentNode`);
      }
    }

    return attached;
  }

  override detach(): boolean {
    const parentNode: IVirtualNodeOrNull = this.parentNode;

    const detached: boolean = super.detach();

    if (detached) {
      this.detachTextNode(parentNode as VirtualNode);
    }

    return detached;
  }

  detachTextNode(
    parentNode: VirtualNode,
  ): void {
    if (parentNode instanceof VirtualElementNode) {
      parentNode.elementNode.removeChild(this.textNode);
    } else {
      throw new Error(`Unsupported parentNode`);
    }
  }
}

/*-----------------------------------------*/

export function checkVirtualNodeConsistency(
  node: VirtualNode,
): void {
  if (node.parentNode === null) {
    if (node.previousNode !== null) {
      throw new Error(`(node.parentNode === null) && (node.previousNode !== null)`);
    }
    if (node.nextNode !== null) {
      throw new Error(`(node.parentNode === null) && (node.nextNode !== null)`);
    }
  }
}

