import { IMulticastReplayLastSource, let$$ } from '@lirx/core';

export type IVirtualNodeOrNull = VirtualNode | null;

export abstract class VirtualNode {

  protected _$parentNode$: IMulticastReplayLastSource<IVirtualNodeOrNull>;
  protected _previousNode: IVirtualNodeOrNull;
  protected _nextNode: IVirtualNodeOrNull;
  protected _firstChild: IVirtualNodeOrNull;
  protected _lastChild: IVirtualNodeOrNull;

  protected constructor() {
    this._$parentNode$ = let$$<IVirtualNodeOrNull>(null);
    this._previousNode = null;
    this._nextNode = null;
    this._firstChild = null;
    this._lastChild = null;
  }

  get parentNode(): IVirtualNodeOrNull {
    return this._$parentNode$.getValue();
  }

  get previousNode(): IVirtualNodeOrNull {
    return this._nextNode;
  }

  get nextNode(): IVirtualNodeOrNull {
    return this._nextNode;
  }

  get firstChild(): IVirtualNodeOrNull {
    return this._firstChild;
  }

  get lastChild(): IVirtualNodeOrNull {
    return this._lastChild;
  }

  contains(
    childNode: VirtualNode,
  ): boolean {
    let node: IVirtualNodeOrNull = childNode;

    do {
      if (node === this) {
        return true;
      } else {
        node = node.parentNode;
      }
    } while (node !== null);

    return false;
  }

  attach(
    parentNode: VirtualNode,
    referenceNode: IVirtualNodeOrNull = null,
  ): boolean {

    if (this.contains(parentNode)) {
      throw new Error(`current node already contains parentNode`);
    }

    if (referenceNode === null) {
      if (
        (this.parentNode === parentNode)
        && (this.parentNode._lastChild === this) // current node is already the last child of parentNode, so we have nothing to do
      ) {
        return false;
      }
    } else {
      if (this._nextNode === referenceNode) { // current node is already before referenceNode, so we have nothing to do
        return false;
      }

      if (referenceNode.parentNode !== parentNode) {
        throw new Error(`referenceNode must have parentNode as parent`);
      }
    }

    // detach current node
    if (this.parentNode !== null) {
      if (this._previousNode === null) { // current node is first child
        this.parentNode._firstChild = this._nextNode;
      } else {
        this._previousNode._nextNode = this._nextNode;
      }

      if (this._nextNode === null) { // current node is last child
        this.parentNode._lastChild = this._previousNode;
      } else {
        this._nextNode._previousNode = this._previousNode;
      }
    }

    this._nextNode = referenceNode;

    if (referenceNode === null) {
      this._previousNode = parentNode._lastChild;

      if (parentNode._lastChild === null) { // empty list
        parentNode._firstChild = this;
        parentNode._lastChild = this;
      } else {
        parentNode._lastChild._nextNode = this;
        parentNode._lastChild = this;
      }
    } else {
      this._previousNode = referenceNode._previousNode;

      if (referenceNode._previousNode === null) { // referenceNode is first child
        parentNode._firstChild = this;
      } else {
        referenceNode._previousNode._nextNode = this;
      }

      referenceNode._previousNode = this;
    }

    this._$parentNode$.emit(parentNode);

    return true;
  }

  detach(): boolean {
    if (this.parentNode === null) {
      return false;
    } else {
      if (this._previousNode === null) { // current node is first child
        this.parentNode._firstChild = this._nextNode;
      } else {
        this._previousNode._nextNode = this._nextNode;
      }

      if (this._nextNode === null) { // current node is last child
        this.parentNode._lastChild = this._previousNode;
      } else {
        this._nextNode._previousNode = this._previousNode;
      }

      this._previousNode = null;
      this._nextNode = null;
      this._$parentNode$.emit(null);
      return true;
    }
  }

  * getChildren(): Generator<VirtualNode> {
    let node: IVirtualNodeOrNull = this._firstChild;
    while (node !== null) {
      yield node;
      node = node._nextNode;
    }
  }

  * getChildrenReversed(): Generator<VirtualNode> {
    let node: IVirtualNodeOrNull = this._lastChild;
    while (node !== null) {
      yield node;
      node = node._previousNode;
    }
  }
}

/*-------------*/

export abstract class VirtualDOMNode extends VirtualNode {
  override attach(
    parentNode: VirtualDOMNode,
    referenceNode: VirtualDOMNode | null = null,
  ): boolean {
    const attached: boolean = super.attach(
      parentNode,
      referenceNode,
    );

    if (attached) {
      const selfDOMNodes: ArrayLike<Node> = this.getSelfDOMNodes();
      const parentDOMNode: Node = parentNode.geParentDOMNode();
      const referenceDOMNode: Node | null = (referenceNode === null)
        ? null
        : referenceNode.getReferenceDOMNode();

      const length: number = selfDOMNodes.length;
      if (length > 1e2) { // TODO pimp limit for optimizations
        const fragment: DocumentFragment = document.createDocumentFragment();
        for (let i = 0; i < length; i++) {
          fragment.insertBefore(selfDOMNodes[i], referenceDOMNode);
        }
        parentDOMNode.insertBefore(fragment, referenceDOMNode);
      } else {
        for (let i = 0; i < length; i++) {
          parentDOMNode.insertBefore(selfDOMNodes[i], referenceDOMNode);
        }
      }
    }

    return attached;
  }

  override detach(): boolean {
    const detached: boolean = super.detach();

    if (detached) {
      const selfDOMNodes: ArrayLike<ChildNode> = this.getSelfDOMNodes() as ArrayLike<ChildNode>;
      for (let i = 0, length = selfDOMNodes.length; i < length; i++) {
        selfDOMNodes[i].remove();
      }
    }

    return detached;
  }

  abstract getSelfDOMNodes(): ArrayLike<Node>;

  abstract geParentDOMNode(): Node;

  abstract getReferenceDOMNode(): Node;
}

/*-------------*/

export abstract class VirtualDOMChildNode extends VirtualDOMNode {
  override geParentDOMNode(): Node {
    throw new Error(`Cannot be used as parent`);
  }
}

/*-------------*/

export class VirtualElementNode<GElementNode extends Element> extends VirtualDOMNode {

  static create<GElementNode extends Element>(
    namespaceURI: string,
    name: string,
    options?: ElementCreationOptions,
  ): VirtualElementNode<GElementNode> {
    return new VirtualElementNode<GElementNode>(
      document.createElementNS(namespaceURI, name, options) as GElementNode,
    );
  }

  protected readonly elementNode: GElementNode;

  protected constructor(
    elementNode: GElementNode,
  ) {
    super();
    this.elementNode = elementNode;
  }

  override getSelfDOMNodes(): Node[] {
    return [
      this.elementNode,
    ];
  }

  override geParentDOMNode(): Node {
    return this.elementNode;
  }

  override getReferenceDOMNode(): Node {
    return this.elementNode;
  }
}

/*-------------*/

export class VirtualContainerNode extends VirtualDOMNode {

  static create(
    name: string,
  ): VirtualContainerNode {
    return new VirtualContainerNode(
      name,
    );
  }

  public readonly name: string;
  protected readonly startNode: Text | Comment;
  protected readonly endNode: Text | Comment;

  protected readonly mode: 'fragment' | 'list';
  protected readonly fragment: DocumentFragment;
  protected readonly nodes: Node[];

  protected constructor(
    name: string,
  ) {
    super();
    this.name = name;
    this.startNode = new Comment(`VIRTUAL-CONTAINER: ${this.name} - START`);
    this.endNode = new Comment(`VIRTUAL-CONTAINER: ${this.name} - END`);

    this.mode = 'list';
    this.fragment = document.createDocumentFragment();
    this.nodes = [];
  }

  override getSelfDOMNodes(): Node[] {
    const parentNode: VirtualDOMNode | null = this.parentNode as VirtualDOMNode | null;

    if (parentNode === null) { // mode fragment
      this.nodes = Array.from(this.fragment);
      return [
        this.fragment,
      ];
    } else {

    }

    // if (this.fragment.firstChild === null) {
    //   // empty fragment
    // } else {
    //   return [
    //     this.fragment,
    //   ];
    // }
    // return (parentNode === null)
    //   ? this.fragment
    //   : parentNode.geParentDOMNode();
    //
    // return [
    //   this.startNode,
    //   this.endNode,
    // ];
  }

  override geParentDOMNode(): Node {
    // protected getParentVirtualDOMNode(): VirtualDOMNode | null {
    //   let node: IVirtualNodeOrNull = this.parentNode;
    //   while (node !== null) {
    //     if (node instanceof VirtualDOMNode) {
    //       return node;
    //     }
    //   }
    //   return null;
    // }

    const parentNode: VirtualDOMNode | null = this.parentNode as VirtualDOMNode | null;
    return (parentNode === null)
      ? this.fragment
      : parentNode.geParentDOMNode();
  }

  override getReferenceDOMNode(): Node {
    return this.endNode;
  }

  // override attach(
  //   parentNode: VirtualNode,
  //   referenceNode: IVirtualNodeOrNull = null,
  // ): boolean {
  //   const attached: boolean = super.attach(
  //     parentNode,
  //     referenceNode,
  //   );
  //
  //   if (attached) {
  //     const attachVirtualContainerNode = (
  //       node: VirtualContainerNode,
  //     ): void => {
  //       const parentNode: IVirtualNodeOrNull = node.parentNode;
  //       if (parentNode instanceof VirtualElementNode) {
  //
  //         const attachVirtualContainerNodeChildrenHavingReferenceNode = (
  //           referenceNode: Node | null,
  //         ): void => {
  //           parentNode.elementNode.insertBefore(this.startNode, referenceNode);
  //
  //           const attachVirtualContainerNodeChildren = (
  //             node: VirtualContainerNode,
  //           ): void => {
  //             for (const child of node.getChildren()) {
  //               if (child instanceof VirtualElementNode) {
  //                 parentNode.elementNode.insertBefore(child.elementNode, referenceNode);
  //               } else if (child instanceof VirtualContainerNode) {
  //                 attachVirtualContainerNodeChildren(child);
  //               } else if (child instanceof VirtualTextNode) {
  //                 parentNode.elementNode.insertBefore(child.textNode, referenceNode);
  //               } else {
  //                 throw new Error(`Unsupported child`);
  //               }
  //             }
  //           };
  //
  //           attachVirtualContainerNodeChildren(this);
  //
  //           parentNode.elementNode.insertBefore(this.endNode, referenceNode);
  //         };
  //
  //         if (referenceNode === null) {
  //           attachVirtualContainerNodeChildrenHavingReferenceNode(null);
  //         } else if (referenceNode instanceof VirtualElementNode) {
  //           attachVirtualContainerNodeChildrenHavingReferenceNode(referenceNode.elementNode);
  //         } else if (referenceNode instanceof VirtualContainerNode) {
  //           attachVirtualContainerNodeChildrenHavingReferenceNode(referenceNode.endNode);
  //         } else if (referenceNode instanceof VirtualTextNode) {
  //           attachVirtualContainerNodeChildrenHavingReferenceNode(referenceNode.textNode);
  //         } else {
  //           throw new Error(`Unsupported referenceNode`);
  //         }
  //
  //       } else if (parentNode instanceof VirtualContainerNode) {
  //         attachVirtualContainerNode(parentNode);
  //       } else {
  //         throw new Error(`Unsupported parentNode`);
  //       }
  //     };
  //     attachVirtualContainerNode(this);
  //
  //     // if (parentNode instanceof VirtualElementNode) {
  //     //   if (referenceNode === null) {
  //     //     parentNode.elementNode.insertBefore(this.startNode, null);
  //     //     // for (const child of this.getChildren()) {
  //     //     //   if (child instanceof )
  //     //     // }
  //     //     parentNode.elementNode.insertBefore(this.startNode, null);
  //     //   } else {
  //     //     // throw new Error(`Unsupported referenceNode`);
  //     //     // if (referenceNode instanceof VirtualElementNode) {
  //     //     //   parentNode.elementNode.insertBefore(this.elementNode, referenceNode.elementNode);
  //     //     // } else if (referenceNode instanceof VirtualTextNode) {
  //     //     //   parentNode.elementNode.insertBefore(this.elementNode, referenceNode.textNode);
  //     //     // } else {
  //     //     //   throw new Error(`Unsupported referenceNode`);
  //     //     // }
  //     //   }
  //     // } else {
  //     //   throw new Error(`Unsupported parentNode`);
  //     // }
  //   }
  //
  //   return attached;
  // }
  //
  // override detach(): boolean {
  //   const parentNode: IVirtualNodeOrNull = this.parentNode;
  //
  //   const detached: boolean = super.detach();
  //
  //   if (detached) {
  //     const detachVirtualContainerNode = (
  //       node: VirtualContainerNode,
  //       parentNode: IVirtualNodeOrNull,
  //     ): void => {
  //       if (parentNode instanceof VirtualElementNode) {
  //         parentNode.elementNode.removeChild(this.startNode);
  //         parentNode.elementNode.removeChild(this.endNode);
  //
  //         const detachVirtualContainerNodeChildren = (
  //           node: VirtualContainerNode,
  //         ): void => {
  //           for (const child of node.getChildren()) {
  //             if (child instanceof VirtualElementNode) {
  //               parentNode.elementNode.removeChild(child.elementNode);
  //             } else if (child instanceof VirtualContainerNode) {
  //               detachVirtualContainerNodeChildren(child);
  //             } else if (child instanceof VirtualTextNode) {
  //               parentNode.elementNode.removeChild(child.textNode);
  //             } else {
  //               throw new Error(`Unsupported child`);
  //             }
  //           }
  //         };
  //
  //         detachVirtualContainerNodeChildren(node);
  //       } else if (parentNode instanceof VirtualContainerNode) {
  //         detachVirtualContainerNode(parentNode, parentNode.parentNode);
  //       } else {
  //         throw new Error(`Unsupported parentNode`);
  //       }
  //     };
  //
  //     detachVirtualContainerNode(this, parentNode);
  //   }
  //
  //   return detached;
  // }

  // detachChildNodes(
  //   parentNode: VirtualNode,
  // ): void {
  //   if (parentNode instanceof VirtualElementNode) {
  //     for (const child of this.getChildren()) {
  //       if (child instanceof VirtualElementNode) {
  //         parentNode.elementNode.removeChild(this.elementNode);
  //       }
  //     }
  //   } else {
  //     throw new Error(`Unsupported parentNode`);
  //   }
  // }
}

/*-------------*/

export class VirtualTextNode extends VirtualDOMChildNode {
  static create(
    value?: string,
  ): VirtualTextNode {
    return new VirtualTextNode(
      new Text(value),
    );
  }

  protected readonly textNode: Text;

  protected constructor(
    textNode: Text,
  ) {
    super();
    this.textNode = textNode;
  }

  get value(): string {
    return this.textNode.data;
  }

  set value(
    input: string,
  ) {
    this.textNode.data = input;
  }

  override getSelfDOMNodes(): Node[] {
    return [
      this.textNode,
    ];
  }

  override getReferenceDOMNode(): Node {
    return this.textNode;
  }
}

/*-----------------------------------------*/

export function checkVirtualNodeConsistency(
  node: VirtualNode,
): void {
  if (node.parentNode === null) {
    if (node.previousNode !== null) {
      throw new Error(`(node.parentNode === null) && (node.previousNode !== null)`);
    }
    if (node.nextNode !== null) {
      throw new Error(`(node.parentNode === null) && (node.nextNode !== null)`);
    }
  }
}

